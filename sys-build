#!/bin/bash
#
#  This shell script is a wrapper to launch the NDK build from the
#  command-line inside an application project path.
#
#  Typical usage is:
#
#     cd $PROJECT_PATH
#     sys-build
#
#  Assuming that the SYS-BUILD root path is in your PATH. However,
#  you can also invoke it directly as:
#
#     $SYS_BUILD_ROOT/sys-build
#
#  This really is a tiny wrapper around GNU Make.
#

# Ensure we get the full path of this script's directory
# this is needed if the caller uses the -C <path> GNU Make
# option, as in:
#
#    cd $SYS_BUILD_ROOT
#    ./sys-build -C <project-path>
#
#PROGDIR=`dirname $0`
#PROGDIR=`cd $PROGDIR && pwd`
#PRODUCT=""
#case $PROGDIR in
#    *\ *) echo "ERROR: NDK path cannot contain space"
#          exit 1
#        ;;
#esac
#
## If NDK_LOG is set to 1 or true in the environment, or the command-line
## then enable log messages below
## Also normalize NDK_HOST_32BIT and NDK_ANALYZE to 1 or 0
#if [ -z "$NDK_LOG" ]; then
#  NDK_LOG=0
#fi
#
#if [ -z "$NDK_HOST_32BIT" ]; then
#  NDK_HOST_32BIT=0
#fi
#
#if [ -z "$NDK_ANALYZE" ]; then
#  NDK_ANALYZE=0
#fi
#
#PROJECT_PATH=
#PROJECT_PATH_NEXT=
#for opt; do
#    if [ -z "$PROJECT_PATH" -a "$PROJECT_PATH_NEXT" = "yes" ] ; then
#        PROJECT_PATH=$opt
#        PROJECT_PATH_NEXT=
#    else
#        case $opt in
#          NDK_LOG=1|NDK_LOG=true)
#            NDK_LOG=1
#            ;;
#          NDK_LOG=*)
#            NDK_LOG=0
#            ;;
#          NDK_HOST_32BIT=1|NDK_HOST_32BIT=true)
#            NDK_HOST_32BIT=1
#            ;;
#          NDK_HOST_32BIT=*)
#            NDK_HOST_32BIT=0
#            ;;
#          NDK_ANALYZE=1|NDK_ANALYZE=true)
#            NDK_ANALYZE=1
#            ;;
#          NDK_ANALYZE=*)
#            NDK_ANALYZE=0
#            ;;
#          NDK_TOOLCHAIN_VERSION=*)
#            NDK_TOOLCHAIN_VERSION=${opt#NDK_TOOLCHAIN_VERSION=}
#            ;;
#          APP_ABI=*)
#            APP_ABI=${opt#APP_ABI=}
#            ;;
#          -C)
#            PROJECT_PATH_NEXT="yes"
#            ;;
#        esac
#    fi
#done
#
#if [ "$NDK_LOG" = "true" ]; then
#  NDK_LOG=1
#fi
#
#if [ "$NDK_HOST_32BIT" = "true" ]; then
#  NDK_HOST_32BIT=1
#fi
#
#if [ "$NDK_ANALYZE" = "true" ]; then
#  NDK_ANALYZE=1
#fi
#
#if [ "$NDK_LOG" = "1" ]; then
#  log () {
#    echo "$@"
#  }
#else
#  log () {
#    : # nothing
#   # echo "SYS-BUILD: $@"
#  }
#fi
#
## Detect host operating system and architecture
## The 64-bit / 32-bit distinction gets tricky on Linux and Darwin because
## uname -m returns the kernel's bit size, and it's possible to run with
## a 64-bit kernel and a 32-bit userland.
##
#HOST_OS=$(uname -s)
#case $HOST_OS in
#  Darwin) HOST_OS=darwin;;
#  Linux) HOST_OS=linux;;
#  FreeBsd) HOST_OS=freebsd;;
#  CYGWIN*|*_NT-*) HOST_OS=cygwin;;
#  *) echo "ERROR: Unknown host operating system: $HOST_OS"
#     exit 1
#esac
#log "HOST_OS=$HOST_OS"
#
#HOST_ARCH=$(uname -m)
#case $HOST_ARCH in
#    i?86) HOST_ARCH=x86;;
#    x86_64|amd64) HOST_ARCH=x86_64;;
#    *) echo "ERROR: Unknown host CPU architecture: $HOST_ARCH"
#       exit 1
#esac
#log "HOST_ARCH=$HOST_ARCH"
#
## Detect 32-bit userland on 64-bit kernels
#HOST_TAG="$HOST_OS-$HOST_ARCH"
#case $HOST_TAG in
#  linux-x86_64|darwin-x86_64)
#    # we look for x86_64 or x86-64 in the output of 'file' for our shell
#    # the -L flag is used to dereference symlinks, just in case.
#    file -L "$SHELL" | grep -q "x86[_-]64"
#    if [ $? != 0 ]; then
#      HOST_ARCH=x86
#      log "HOST_ARCH=$HOST_ARCH (32-bit userland detected)"
#    fi
#    ;;
#esac
#
## Check that we have 64-bit binaries on 64-bit system, otherwise fallback
## on 32-bit ones. This gives us more freedom in packaging the NDK.
#LOG_MESSAGE=
#if [ $HOST_ARCH = x86_64 ]; then
#  if [ ! -d $PROGDIR/prebuilt/$HOST_TAG ]; then
#    HOST_ARCH=x86
#    LOG_MESSAGE="(no 64-bit prebuilt binaries detected)"
#  fi
#
#  if [ "$NDK_HOST_32BIT" = "1" ]; then
#    HOST_ARCH=x86
#    LOG_MESSAGE="(force 32-bit host toolchain)"
#  fi
#fi
#
#HOST_TAG=$HOST_OS-$HOST_ARCH
## Special case windows-x86 -> windows
#if [ $HOST_TAG = windows-x86 ]; then
#  HOST_TAG=windows
#fi
#log "HOST_TAG=$HOST_TAG $LOG_MESSAGE"
#
## If GNUMAKE is defined, check that it points to a valid file
#if [ -n "$GNUMAKE" ] ; then
#    ABS_GNUMAKE=`which $GNUMAKE 2> /dev/null`
#    if [ $? != 0 ] ; then
#        echo "ERROR: Your GNUMAKE variable is defined to an invalid name: $GNUMAKE"
#        echo "Please fix it to point to a valid make executable (e.g. /usr/bin/make)"
#        exit 1
#    fi
#    GNUMAKE="$ABS_GNUMAKE"
#    log "GNUMAKE=$GNUMAKE (from environment variable)"
#else
#    # Otherwise use the prebuilt version for our host tag, if it exists
#    # Note: we intentionally do not provide prebuilt make binaries for Cygwin
#    # or MSys.
#    GNUMAKE=$PROGDIR/prebuilt/$HOST_TAG/bin/make
#    if [ ! -f "$GNUMAKE" ]; then
#        # Otherwise, use 'make' and check that it is available
#        GNUMAKE=`which make 2> /dev/null`
#        if [ $? != 0 ] ; then
#            echo "ERROR: Cannot find 'make' program. Please install Cygwin make package"
#            echo "or define the GNUMAKE variable to point to it."
#            exit 1
#        fi
#        log "GNUMAKE=$GNUMAKE (system path)"
#    else
#        log "GNUMAKE=$GNUMAKE (NDK prebuilt)"
#    fi
#fi
#
## On Windows, when running under cygwin, check that we are
## invoking a cygwin-compatible GNU Make binary. It is unfortunately
## common for app developers to have another non cygwin-compatible
## 'make' program in their PATH.
##
#if [ "$OSTYPE" = "cygwin" ] ; then
#    GNUMAKE=`cygpath -u $GNUMAKE`
#    PROGDIR_MIXED=`cygpath -m $PROGDIR`
#    CYGWIN_GNUMAKE=`$GNUMAKE -f "$PROGDIR_MIXED/build/core/check-cygwin-make.mk" 2>&1`
#    if [ $? != 0 ] ; then
#        echo "ERROR: You are using a non-Cygwin compatible Make program."
#        echo "Currently using: `cygpath -m $GNUMAKE`"
#        echo ""
#        echo "To solve the issue, follow these steps:"
#        echo ""
#        echo "1. Ensure that the Cygwin 'make' package is installed."
#        echo "   NOTE: You will need GNU Make 3.81 or later!"
#        echo ""
#        echo "2. Define the GNUMAKE environment variable to point to it, as in:"
#        echo ""
#        echo "     export GNUMAKE=/usr/bin/make"
#        echo ""
#        echo "3. Call 'ndk-build' again."
#        echo ""
#        exit 1
#    fi
#    log "Cygwin-compatible GNU make detected"
#fi
#. $PROGDIR/build/tools/envsetup.sh
#
# sys_build_all_parameters=( $@ )
#
#__sys_build_check_args $@
##if $1 eq config then return 1 without return 0
#$echo "$@"
#if [ ! $? -eq 0 ];then
# exit $?
#fi
#
#
#$GNUMAKE -f $PROGDIR/build/core/build-local.mk  $@ GNUMAKE=$GNUMAKE 


# 1.Create Application.mk with write APP_XXX variable.
# 2.Create Makefile at the runing this command directory.

FILE=config.mk

usage()
{
	echo "Usage:"
	echo "sys-build --arch <arch> --abi <abi> [opt...]"
	echo "   Usage Option:"
	echo "     --arch           arm|arm64|x86|x86_64"
	echo "     --abi            armeabi|armea-v7a|arm64-v8a|x86|x64"
	echo "     --plat           android|other"
	echo "     --board          board name"
	echo "     --aliasboard     alias board name"
	echo "     --vendor         vendor name"
	echo "     --output         Specify out put direcotry, default ./out"
	echo "     --printlog       1 | 0"
	echo "     --modules        Specify should be compiled module"
	echo "     --sysroot        Specify sysroot"
	echo "     --toolchain      toolchain prefix"
	echo "     --buildscript    Build script file"
	echo "     --stl            Append stl support"
	echo "     --releasepath    Setup release direcotry, default ./out/release"
	echo "     --optmized       debug|release"
}

application_vars=( APP_BUILD_SCRIPT \
	               APP_OPTIM \
				   APP_STL \
				   APP_OUTPUT_DIR \
				   APP_DEBUG_MODULES \
				   NDK_LOG \
				   APP_MODULES \
				   APP_ARCH \
				   APP_ABI \
				   APP_PLATFORM \
				   APP_BOARD \
				   APP_ALIAS_BOARD \
				   APP_TOOLCHAIN \
				   APP_TOOLCHAIN_SYSROOT \
				   APP_RELEASE_DIR )

load_default_value_for_vars()
{
	 APP_BUILD_SCRIPT="\$(APP_PROJECT_PATH)/make.mk"
	 APP_OPTIM=release
	 APP_STL="\$(empty)"
	 APP_OUTPUT_DIR=out
	 APP_DEBUG_MODULES="\$(empty)"
	 NDK_LOG="\$(empty)"
	 APP_MODULES="\$(empty)"
	 APP_ARCH=x86_64
	 APP_ABI=x86_64
	 APP_PLATFORM=x86_64
	 APP_BOARD=unknow
	 APP_ALIAS_BOARD=unknow
	 APP_TOOLCHAIN=x86_64-linux-gnu-
	 APP_TOOLCHAIN_SYSROOT="\$(empty)"
	 APP_RELEASE_DIR=out/release
}

load_notes_for_vars()
{

NOTES_VERSION="
#=================================Sys-build=================================#
# Version: 1.0.0
# Author:  lichao@snailgame.net
# Date:    `date`
#===========================================================================#
"
NOTES_APP_BUILD_SCRIPT="
# To point a make.mk scritp, it's will be contains by sys-build at first time.
# if the variable undefine then using \$(APP_PROJECT_PATH)/make.mk as default.
"
NOTES_APP_OPTIM="
The option i
"
	NOTES_APP_STL="#"
	NOTES_APP_OUTPUT_DIR="#"
	NOTES_APP_DEBUG_MODULES="#"
	NOTES_NDK_LOG="#"
	NOTES_APP_MODULES="#"
	NOTES_APP_ARCH="#"
	NOTES_APP_ABI="#"
	NOTES_APP_PLATFORM="#"
	NOTES_APP_BOARD="#"
	NOTES_APP_ALIAS_BOARD="#"
	NOTES_APP_TOOLCHAIN="#"
	NOTES_APP_TOOLCHAIN_SYSROOT="#"
	NOTES_APP_RELEASE_DIR="#"
}

get_notes_for_var()
{
	D="string=\$NOTES_$1"
	eval $D
	ret="$string"
}

write_application()
{
 get_notes_for_var "VERSION"
 echo "$ret" > $1

 for var in ${application_vars[*]}
 do
	 get_notes_for_var "${var}"
	 echo -e "$ret" >> $1
	 D="v=\$${var}"
	 eval $D
	 echo "${var} := ${v}" >> $1
 done
 return 0
}

load_notes_for_vars
load_default_value_for_vars

#TEMP=`getopt -- --long arch:,abi: -- "$@" 2>/dev/null`

args=arch:,abi:,plat:,board:,aliasboard:,vendor:,output:,printlog:,modules:,sysroot:,toolchain:,buildscript:,stl:,releasepath:,optmized:
TEMP=`getopt -- --long ${args} -- "$@" 2>/dev/null`

[ $? != 0 ] && echo -e "\033[31mERROR: unknown argument! \033[0m\n" && usage && exit 1

eval set -- "$TEMP"

while :
do
	[ -z "$1" ] && break;
	case "$1" in
		--arch)
			APP_ARCH=$2;shift 2
			;;
		--abi)
			APP_ABI=$2;shift 2
			;;
		--plat)
			APP_PLATFORM=$2; shift 2
			;;
		--board)
			APP_BOARD=$2; shift 2
			;;
		--aliasboard)
			APP_ALIAS_BOARD=$2; shift 2
			;;
		--vendor)
			APP_VENDOR=$2; shift 2
			;;
		--output)
			APP_OUTPUT_DIR=$2; shift 2
			;;
		--printlog)
			NDK_LOG=$2; APP_DEBUG_MODULES=$2; shift 2
			;;
		--modules)
			APP_MODULES=$2; shift 2
			;;
		--sysroot)
			APP_TOOLCHAIN_SYSROOT=$2; shift 2
			;;
		--toolchain)
			APP_TOOLCHAIN=$2; shift 2
			;;
		--buildscript)
			APP_BUILD_SCRIPT=$2; shift 2
			;;
		--stl)
			APP_STL=$2; shift 2
			;;
		--releasepath)
			APP_RELEASE_DIR=$2; shift 2
			;;
		--optmized)
			APP_OPTIM=$2; shift 2
			;;
		--)
			shift
			;;
		${args})
			shift
			;;
		*)
			echo "Bad parameters ($1)" && usage && exit 1
	esac

done

echo "Create config.mk..."
write_application ${FILE}

if [ $? -eq 0 ]
then
	echo "Creating Makefile..."
	echo "include `dirname $0 `/sys-build.mk" > Makefile
fi

