#===============================================================================#
#								make.mk文件说明									#
#===============================================================================#

一、概述：
	make.mk文件其实质和Android ndk中的Android.mk编译脚本文件一样，是一个普通
的Makefile文件，因此，它的语法规则完全和标准的Makefile规则一样，在里面你可以定义
自己的目标、变量，函数等，不过在定义的时候需要注意如下二点：
	***********************************************************************************
	*	1、尽量不要使用以LOCAL_、PRIVATE_、NDK_ 、TARGET_或者 APP_打头的名字作为变量。*
	*	2、尽量不要与提供的命令行如config、help、make-xxx,shell-xxx等名字作为目标名。 *
    ***********************************************************************************

二、make.mk中可以引用的变量
	make.mk中可以引用编译系统已经定义好的一些变量，下面依次说明：

LOCAL_PATH：
	表示当前make.mk所在目录，它的值总是等于$APP_PROJECT_PATH变量值的相
对路径。每一个make.mk中仅仅只能被定义一次，通常都被定义在make.mk文件的第一行，
它的功能是确保编译系统能正确找到该make.mk中定义的文件，定义方式如下
LOCAL_PATH := $(call my-dir)

---------------------------------------------------------------------------------
LOCAL_MODULE：
	用于表示一个模块的名字，必须是唯一的，在编译动态库、静态库或者可执行文件
时它的名字决定了最终文件生成的名字，对于库文件自动添加lib前缀（如果模块名已有lib
前缀则不在添加）。如果是动态库则自动添加.so后缀，如果是静态库则自动添加.a后缀。
因此，在赋值时如果编译的是库文件，我们一般不需要添加lib前缀和相关的后缀（.so/.a）。
	模块名出了与最终编译生产的文件名有关系外还与模块引用相关，如一个模块编译时
需要用到一个动态库模块，这时直接通过LOCAL_SHARED_LIBRARIES := $(LOCAL_MODULE)声明
需要引用的动态库模块即可，详情参考LOCAL_SHARED_LIBRARIES变量说明。
	如果该模块指定了LOCAL_MODULE_FILENAME变量，则生成的名字完全由它决定。具体
可以参见这个变量的说明。

---------------------------------------------------------------------------------
LOCAL_MODULE_FILENAME：
	声明一个模块编译后最终生成的文件名，其值的后缀不能为“.so”或者“.a”。对于的
模块类型最终生成文件的命名如下：
  动态库模块    ：$(LOCAL_MODULE_FILENAME).so
  静态库模块    ：$(LOCAL_MODULE_FILENAME).a
  可执行程序    ：$(LOCAL_MODULE_FILENAME)
  内核/boot模块 : 无效
  第三方二进制  : 无效
 
 ---------------------------------------------------------------------------------
LOCAL_SRC_FILES：
	定义该模块依赖的所有源文件，所有源文件均为相对路径，编译系统自动为它加上
$(LOCAL_PATH)
，因此，你不必自己添加$(LOCAL_PATH)路径前缀。
	在预处理模块中该值取值等于需要预处理的库的路径，它必须真实有效。

---------------------------------------------------------------------------------
LOCAL_CPP_EXTENSION：
	声明当前c++源文件的扩展名支持，当前编译系统默认支持的c++扩展名有
“.cc .cp .cxx .cpp .CPP .c++ .C”，默认情况下编译系统将过滤已经定义的扩展名文件。
其他后缀的源文件将不会被编译。考虑如下情形：
	LOCAL_SRC_FILES = 1.c 2.cc 3.cp \
			  4.cxx 5.cpp 6.CPP 7.c++ 8.CC

   1、如果该变量没有被定义，则8.CC文件将不会被编译
   2、定义LOCAL_CPP_EXTENSION := .CC，则只有1.c和8.CC被编译，此时修改了C++文件
的默认后缀为.CC
   3、如果定义LOCAL_CPP_EXTENSION := .cc .cp .cxx .cpp .CPP .c++ .CC ,则所有的
文件都被编译
   4、所有以.c为后缀的文件总是被编译。

----------------------------------------------------------------------------------
LOCAL_CPP_FEATURES：
	定义当前模块的C++特性支持，取值仅为“ rtti和exceptions”，如下例子说明：
LOCAL_CPP_FEATURES := exceptions 则相当于LOCAL_CPPFLAGS += -fexceptions

----------------------------------------------------------------------------------
LOCAL_C_INCLUDES：
	声明当前模块依赖的头文件路径列表，路径的有效性不做检查，它的路径可以为相对路
径或者绝对路径，为了make.mk的健壮性，在给定相对路径时最好加上$(LOCAL_PATH)。通常的用
法如下：
   LOCAL_C_INCLUDES := $(LOCAL_PATH) \
                       $(LOCAL_PATH)/../inc

----------------------------------------------------------------------------------
LOCAL_ALLOW_UNDEFINED_SYMBOLS:
	默认为false，如果该变量定义为true,则链接阶段关闭符号未定义异常功能。

----------------------------------------------------------------------------------
LOCAL_DISABLE_FORMAT_STRING_CHECKS:
	默认为false，入股该变量定义为true，则编译阶段关闭对print函数的格式串检查功能。

----------------------------------------------------------------------------------
LOCAL_CFLAGS：
	定义该模块编译阶段的标志，如定义一些宏等。

----------------------------------------------------------------------------------
LOCAL_CPPFLAGS：
	定义该模块编译阶段的标志，如定义一些宏等，该变量仅对c++源文件有效，编译系统中
默认将LOCAL_CFLAGS定义的值追加到该变量值的前面。

----------------------------------------------------------------------------------
LOCAL_STATIC_LIBRARIES：
	定义该模块需要引用其他模块的静态库，注意，这里是模块名（由$(LOCAL_MODULE)定
义的值）而非静态库名。如果引用的模块名含有lib，则编译系统自动去掉lib前缀。

----------------------------------------------------------------------------------
LOCAL_SHARED_LIBRARIES：
	定义该模块需要引用其他模块的动态库，注意，这里是模块名（由$(LOCAL_MODULE)定
义的值）而非动态库名。如果引用的模块名含有lib，则编译系统自动去掉lib前缀。

----------------------------------------------------------------------------------
LOCAL_WHOLE_STATIC_LIBRARIES：
	用于编译动态库时指定依赖的静态库，用法同LOCAL_STATIC_LIBRARIES类似，不过会将
引用的静态库模块中的所有符号都提取出来链接到动态库中。通常用于重新封装静态库为动态库。

----------------------------------------------------------------------------------
LOCAL_LDLIBS：
	定义链接阶段所依赖的库，使用-l指定，例如：LOCAL_LDLIBS := -llog

----------------------------------------------------------------------------------
LOCAL_LDFLAGS:
	定义链接阶段的标志，如:LOCAL_LDFLAGS := -Wl,-z,now

----------------------------------------------------------------------------------
LOCAL_EXPORT_LDLIBS：
	定义该模块需要EXPORT的标志，该行为不同于shell中的export，编译系统通过一个变量
记录被export出去的标志，当这个模块被其他模块引用时，引用的模块中定义的变量LOCAL_LDLIBS
值最终在编译是被扩展为LOCAL_LDLIBS :=$(LOCAL_LDLIBS) $(LOCAL_EXPORT_LDLIBS),这让引用的
模块只关注自己模块的编译而不必知道在使用被引用的模块时到底需要定义什么样的标志。考虑如
下情形：

#我们定义如下静态库模块，由于mythread.c中用到到了线程库，
#所以我们将-lpthead链接标志export出去
LOCAL_PATH := $(call my-dir)
LOCAL_MODULE := threadtest
LOCAL_SRC_FILES := mythread.c
LOCAL_EXPORT_LDLIBS := -lpthread
include $(BUILD_STATIC_LIBRARY)

#下面的可执行文件模块需要引用上面的静态库
LOCAL_PATH := $(call my-dir)
LOCAL_MODULE := test
LOCAL_SRC_FILES := test.c
LOCAL_LDLIBS := -llog
LOCAL_STATIC_LIBRARIES := threadtest
include $(BUILD_EXECUTABLE)

在test模块中我们引用了静态库模块，由于静态库模块定义了LOCAL_EXPORT_LDLIBS，因此，test
模块的LOCAL_LDLIBS变量值最终被自动扩展为 LOCAL_LDLIBS := -lpthread -llog

----------------------------------------------------------------------------------
LOCAL_EXPORT_CFLAGS：
	定义该模块export出去的cflags标志，比如一个宏，用法参考LOCAL_EXPORT_LDLIBS变量。

----------------------------------------------------------------------------------
LOCAL_EXPORT_CPPFLAGS：
	定义该模块export出去的CPPFLAGS标志，比如一个宏，用法参考LOCAL_EXPORT_LDLIBS变量
不过仅用于C++源文件。

----------------------------------------------------------------------------------
LOCAL_EXPORT_C_INCLUDES：
	定义该模块export出去的头文件路径，用法参考LOCAL_EXPORT_LDLIBS变量。

----------------------------------------------------------------------------------
LOCAL_FILTER_ASM：
	该变量记录需要过滤ASM文件的目标规则，它可以让源文件先编译为asm汇编文件，在通
过我们指定的规则过滤掉每一个汇编文件中的内容得到新的汇编文件，接着在把新的汇编文件编
译为.o文件，它的值必须是一条单一的shell命令，在执行该命令的时候第一个参数为源文件产生
的汇编文件，第二个参数目标汇编文件。考虑如下情形：
	cpp ----------1-------> a.S --------2--------> a.o
但是如果定义了该变量就会变为：
	a.cpp--------1------>a.S---------2--------->a.filtered.S--------3-------->a.o
在第二种情形中，我们的第二步将a.S变为a.filtered.S就是我们规定的过滤动作，假设我们定义
LOCAL_FILTER_ASM := cp，那第二步可以理解为：
$cp $1 $2
$1 就是我们的a.S，通过cp命令我们得到了新的$2文件，也就是我们的a.filtered.S它将a.S重新进行
装配后得到新的汇编文件，并最终将新的汇编文件编译为.o。
	
----------------------------------------------------------------------------------
LOCAL_LINK_MODE：
	该变量指明当前模块在链接的时候是采用gcc还是采用g++，它的取值只能为c或者c++，缺省
方式为c方式，如果采用缺省方式就意味着你编写的模块（可执行程序，动态库）在目标机上运行需
要提供libstdc++库，如果你需要声明当前模块采用gcc作为最终的链接，示例如下：
		LOCAL_PATH := $(call my-dir)
		include $(CLEAR_VARS)
		LOCAL_MODULE := test
		LOCAL_SRC_FILES := test.c
		LOCAL_LINK_MODE := c
		include $(BUILD_SHARED_LIBRARY)

最终通过命令$readelf libtest.so -d是否依赖了libstdc++库。

----------------------------------------------------------------------------------
LOCAL_RELATE_MODE：
	该变量用于指明当前模块涉及的使用范围，其取值为board、 plat、 arch 、compiler中
的一个，缺省为board，各个取值说明如下所示：

	board	：声明当前模块涉及板级配置，如果当前目标板配置改变，该模块就需要重新编译。
		  生成目录位于$(NDK_APP_DST_DIR)或者$(TARGET_OUT)

	plat	:声明当前模块涉及平台配置，如果目标平台发生改变，则该模块就需要重新编译
		 生成的目录位于$(TARGET_OUT)../或者$(NDK_APP_DST_DIR)../

	arch	：声明当前模块涉及架构，如果目标架构发生改变，则该模块就需要重新编译，生
		  成的目录位于$(TARGET_OUT)../../或者$(NDK_APP_DST_DIR)../../

	compiler：声明当前模块仅涉及编译器，如果编译器发生变化，则该模块需要重新编译生成
		  的目录位于$(APP_OUTPUT_DIR)/libs/$(TOOLCHAIN_NAME)或者$(APP_OUTPUT_DIR)/
		  obj/$(TOOLCHAIN_NAME)若TOOLCHAIN_NAME为空则默认为：x86默认为x86或者x86_64

	**注意**：如果该模块是内核、bootloader或者第三方模块，则由LOCAL_TARGET_COPY_FILES指定的
文件将根据LOCAL_RELATE_MODE被复制到具体的目录，缺省为$(TARGET_OUT)，如果是预处理模块，仅仅在
只有被其他模块依赖的情况下该定义才有效，对于动态库将根据该模式被复制到obj相关目录下并strip
后安装到libs相关目录，对于静态库不做任何动作。

----------------------------------------------------------------------------------
LOCAL_TARGET_TOP：
	指定源码目录树或者第三方二进制入口目录，仅用于编译内核、boot和第三方二进制，其值可
以是一个相对路径或者绝对路径。相对路径最好加上$(LOCAL_PATH)以增强make.mk的健壮性。

----------------------------------------------------------------------------------
LOCAL_TARGET_CONFIG：
	指定makefile配置文件，仅用于编译内核和boot，如果是内核模块，则指定的config文件必须
存在于$(LOCAL_TARGET_TOP)/arch/$(TARGET_ARCH)/configs/$(LOCAL_TARGET_CONFIG)_defconfig,如果
是bootloader则在$(LOCAL_TARGET_TOP)/Makefile中必须有对应的$(LOCAL_TARGET_CONFIG)_config目标。

----------------------------------------------------------------------------------
LOCAL_TARGET_RULER：
	指定makefile编译目标，仅用于编译内核和boot，如果该值被定义，则在$(LOCAL_TARGET_TOP)/
Makefile中必须有对应的目标$(LOCAL_TARGET_RULER).

----------------------------------------------------------------------------------
LOCAL_TARGET_TOOLCHAIN:
	指定私有make的交叉编译器，仅用于编译内核和boot，如果该值被定义，它将覆盖由
Application.mk中定义的编译器前缀，覆盖仅对本模块有效。这为单独编译内核和bootloader指定编译器是
非常有用的。

----------------------------------------------------------------------------------
LOCAL_TARGET_COPY_FILES：
	该变量仅用于编译第三方二进制或者内核模块或bootloader模块，其作用是用于记录需要从由
变量LOCAL_TARGET_TOP指定的目录中复制的文件列表。
	其原理是当编译系统进入当前模块指定的LOCAL_TARGET_TOP目录执行完由LOCAL_TARGET_CMD定
义的命令后，由它复制由该变量定义的所有文件及文件夹到指定目录。

**注意**：
     1、编译系统会在它指定的每一个需要复制的文件路径前加上$(LOCAL_TARGET_TOP)值，因此，你只
需要指定相对路径即可。
     2、由它指定的文件最终的复制目录位于$(TARGET_OUT)中，并且为每一个复制的文件名加上模块名
前缀，以防止复制的文件出现同名覆盖。
     3、该模块是一个第三方二进制模块，如果定义了LOCAL_RELATE_MODE，则复制的目标路径由
LOCAL_RELATE_MODE得出。
     4、如果该模块定义了LOCAL_RELEASE_PATH，则复制目标路径由LOCAL_RELEASE_PATH指定，并去掉
前缀。

----------------------------------------------------------------------------------
LOCAL_TARGET_CMD ：
	指定需要执行的shell命令，仅用于编译第三方二进制。多条命令用";"隔开，如果一条命令执行
失败则会终止当前项目的编译。

----------------------------------------------------------------------------------
LOCAL_DEPS_MODULES：
	该变量作用范围所有模块，它指定了当前模块在编译前需要先编译的模块。在非第三方模块下使用
该变量只能做编译先后的依赖，并不能将指定的依赖目标的编译结果作为本模块的输入参数。

----------------------------------------------------------------------------------
LOCAL_RELEASE_PATH：
	该变量用于指定本模块编译完成后最终需要发布到哪里，它的值可以为多个发布路径，多个路径
之间用“;”隔开。如果指定的APP_OPTIM为debug，则对于动态库和静态库以及所有可执行文件发布未strip
版本，也就是位于out/obj下的板级目录文件，否则为out/libs下strip过的文件。它的发布过程就是拷贝
过程。对于第三方二进制模块、内核和boot模块，发布的内容由变量LOCAL_TARGET_COPY_FILES指定，它将
直接复制所指定的文件集到每一个发布目录。对于预处理模块将直接复制由LOCAL_SRC_FILES指定的文件到
发布目录。

----------------------------------------------------------------------------------
CLEAR_VARS：
	指向一个清除指定变量的脚本，用法include $(变量)，它通常被定义在每一个模块的开始位置，
用于清除上一个模块定义留下的变量值。

----------------------------------------------------------------------------------
BUILD_SHARED_LIBRARY：
	指向一个编译共享库的脚本，它说明当前面模块编译为动态库，通常被定义到模块的最后一行。

----------------------------------------------------------------------------------
BUILD_STATIC_LIBRARY
	指向一个编译静态库的脚本，它说明当前面模块编译为静态库，通常被定义到模块的最后一行。

----------------------------------------------------------------------------------
BUILD_KERNEL：
	指向一个编译内核的脚本，它说明当前面模块编译为内核，通常被定义到模块的最后一行。

----------------------------------------------------------------------------------
BUILD_BOOTLOADER：
	参考BUILD_KERNEL说明，不过是编译bootloader。

----------------------------------------------------------------------------------
BUILD_TH3_BINARY：
	参考BUILD_KERNEL说明，不过是编译第三方二进制。

----------------------------------------------------------------------------------
BUILD_TEST：
	参考BUILD_KERNEL说明，不过是编译测试程序，其实质就是编译可支持程序。

----------------------------------------------------------------------------------
BUILD_EXECUTABLE：
	参考BUILD_TEST，不过是编译可执行程序。

----------------------------------------------------------------------------------
PREBUILT_SHARED_LIBRARY：
	参考BUILD_SHARED_LIBRARY，不过是预编译已有的动态库。

----------------------------------------------------------------------------------
PREBUILT_STATIC_LIBRARY：
	参考PREBUILT_SHARED_LIBRARY不过是预编译已有的静态库。

----------------------------------------------------------------------------------
TARGET_ARCH：
	只读的，表示当前编译环境的架构

----------------------------------------------------------------------------------
TARGET_PLATFORM：
	只读的，表示当前编译环境的平台

----------------------------------------------------------------------------------
TARGET_ABI：
	只读的，表示当前编译环境的ABI

----------------------------------------------------------------------------------
TARGET_BOARD：
	只读的，表示当前编译环境的目标板

----------------------------------------------------------------------------------
TARGET_VENDOR：
	只读的，表示当前编译环境的目标板厂商

----------------------------------------------------------------------------------
APP_PROJECT_PATH：
	只读的，表示执行sys-build时的绝对路径（工作路径）

----------------------------------------------------------------------------------
TOOLCHAIN_NAME：
	只读的，表示当前编译环境的编译器名字（无路径的编译器前缀）,设定义
APP_ARM_TOOLCHAIN := /opt/arm9q/bin/arm-linux-,则该变量的值为:arm-none-linux-gnueabi-
    **注意**:如果变量APP_ARM_TOOLCHAIN未指定则为空。

----------------------------------------------------------------------------------
TOOLCHAIN_ROOT：
	只读的，当前编译器所在目录，设定义APP_ARM_TOOLCHAIN := /opt/arm9q/bin/arm-linux-
则TOOLCHAIN_ROOT的值为:opt/arm9q/bin

----------------------------------------------------------------------------------
TARGET_OUT：
	只读的，表示当前编译系统生成所有未strip过的库和可执行程序的文件夹

----------------------------------------------------------------------------------
NDK_APP_DST_DIR：
	只读的，表示当前编译系统生成的已经strip过的所有动态库和可执行文件目录

----------------------------------------------------------------------------------
TARGET_WORKSPACE：
    只读的，其值总是等于执行sys-build找到的第一个make.mk所在路径，如果在工程的顶层
执行sys-build，则这个值等于工程路径，如果在子make中执行sys-build，其取值等于子make.mk
所在路径。
	默认不需要定义它，如果需要强制指定路径，则可以在平台或板级配置文件中定义
APP_WORKSPACE来修改。

----------------------------------------------------------------------------------
TARGET_SDK_DIR：
    只读的，表示工程总体编译时指向的工程的sdk包路径，它通常依赖于TARGET_WORKSPACE，
注意，如果用户试图编译子make.mk文件，sys-build将会自动检查指向目录的有效性，如果未
定义，将会给出一个警告。取值可以在平台或板级配置文件中定义APP_SDK_DIR来修改它，或
者直接通过命令行传入。

----------------------------------------------------------------------------------
TARGET_LSP_DIR：
    只读的，表示工程总体编译时指向的工程的lsp路径，它通常依赖于TARGET_WORKSPACE，
注意，如果用户试图编译子make.mk文件，sys-build将会自动检查指向目录的有效性，如果
未定义，将会给出一个警告。取值可以在平台或板级配置文件中定义APP_LSP_DIR来修改它，
或者直接通过命令行传入。

----------------------------------------------------------------------------------
TARGET_RELEASE_DIR：
    只读的，定义了对应平台的发布路径前缀，可以在平台或板级配置文件中定义
APP_RELEASE_DIR来修改它，或者直接通过命令行传入。

----------------------------------------------------------------------------------
TARGET_ALIAS_BOARD
    只读的，表示当前板级的别名，如果别名未定义则等效于TARGET_BOARD。

三、make.mk中可引用的函数
	编译系统为make.mk文件定义了一些有用的函数，以满足make.mk更多的需求，写出移
植性更好的make.mk脚本。

----------------------------------------------------------------------------------
my-dir：
	说明	：获取makefile最后一次包含脚本文件的脚本路径。
	用法示例：v := $(call my-dir)

----------------------------------------------------------------------------------
this-makefile：
	说明	：返回当前makefile全路径
	用法示例：curr_make := $(call this-makefile)

----------------------------------------------------------------------------------
all-makefiles-under：
	说明	：返回指定目录下所有子目录的make.mk文件
	用法示例：
设有如下目录结构：
	./../subs/subs1/make.mk 
	./../subs/subs2/make.mk 
	./../subs/subs3/mymake/make.mk 
则执行 mymakes := $(call all-makefiles-under,./../subs)后mymakes的值为：
mymakes := ./../subs/subs1/make.mk ./../subs/subs2/make.mk

----------------------------------------------------------------------------------
all-subdir-makefiles：
	说明	：返回当前目录下所有子目录的make.mk文件，它相当于
$(call all-makefiles-under,$(LOCAL_PATH))
	用法示例：subs_makes := $(call all-subdir-makefiles)

----------------------------------------------------------------------------------
include-makefile：
	说明	：包含指定路径下的make.mk文件
	用法示例：$(call include-makefile,../subs/make.mk)

----------------------------------------------------------------------------------
include-makefiles：
	说明	：包含多个make.mk列表
	用法示例：$(call include-makefiles, make.mk ../make.mk)
相当于执行：
$(call include-makefile,make.mk)
$(call include-makefile,../make.mk)

----------------------------------------------------------------------------------
include-all-subs-makefile：
	说明	:递归查找并包含指定目录下的所有make.mk文件
	用法示例：
设有如下目录树结构：
	./../subs/make.mk
	./../subs/subs1/make.mk 
	./../subs/subs2/dir1/make.mk 
	./../subs/subs2/dir1/dir2/make.mk 
则执行$(call include-all-subs-makefile,./../subs1 ./../subs2)后相当于执行如下命令：
$(call include-makefiles,./../subs/subs1/make.mk \
			./../subs/subs2/dir1/make.mk \
			 ./../subs/subs2/dir1/dir2/make.mk)


----------------------------------------------------------------------------------
get-all-wildcard-files:
	说明	：返回指定路径下所有匹配后缀的所有文件
	用法示例：
设有如下目录树：
	./../subs/make.mk
	./../subs/subs1/test.cpp
	./../subs/subs1/test.c
则执行 files := $(call get-all-wildcard-files,./../subs ./../subs/subs1,.c .cpp .mk)
后files的值等于：./../subs/make.mk ./../subs/subs1/test.cpp ./../subs/subs1/test.c

----------------------------------------------------------------------------------
get-all-archs：
	说明	：返回所有支持的架构，它将扫描编译系统根目录下的build/configs的所
有子目录，并返回所有结果。
	用法示例：$(call get-all-archs)

----------------------------------------------------------------------------------
get-all-platforms：
	说明	：返回指定架构下所有支持的平台，它将扫描build/configs/<arch>下的子目录
，并返回结果。
	用法示例：$(call get-all-platforms,arm)

----------------------------------------------------------------------------------
get-all-boards：
	说明：	返回指定架构和平台下所有支持的板子，它将扫描build/configs/<arch>/
<platform>下的所有文件，排除common_config并返回结果。
	用法示例：$(call get-all-boards,arm,a5s)

----------------------------------------------------------------------------------
get-all-abis：
	说明：返回指定架构下所有支持的ABI，arm架构下支持的ABI有armeabi和armeabi-v7a,
x86架构下的ABI为x86，mips架构下的abi为mips，ppc架构下的abi为ppc。
	用法示例：$(call get-all-abis,arm)

----------------------------------------------------------------------------------
add-module-clean：
	说明：用于追加一个自定义清除目标支持，通常情况下您不需要定义自己的清除目标，除非
您确实需要。该函数的参数一指定模块名，参数二指定目标名，参数二指定的目标将被自动加入
到目标 clean-<参数一> 的依赖列表。如果参数一为空，则指定目标将被加入到全局的clean中。
	用法示例：$(call add-module-clean,hello_module,my_module_clean)或者
$(call add-module-clean,,my_clean)，此时目标my_module_clean将被加入到clean-hello_module
的依赖列表，my_clean将被加入到clean的依赖列表。
    **注意**：sys-build将会通过匹配clean-$1与$2是否相等来确定这个$2是否非法，以防止目
标冲突。

四、一个普通的make.mk文件
	一个普通的make.mk文件如下：
-----------------------------------------------------------
  1 LOCAL_PATH := $(call my-dir)
  2 include $(CLEAR_VARS)
  3 LOCAL_MODULE := hello
  4 LOCAL_SRC_FILES := hello.c
  5 LOCAL_C_INCLUDES := \
  6                $(LOCAL_PATH)/../ \
  7                $(LOCAL_PATH)/../..
  8 include $(BUILD_EXECUTABLE)
-----------------------------------------------------------
第一行：必须的，定义了LOCAL_PATH，以方便编译系统定位源文件位置。
第二行：清除上一次定义的残留变量值。
第三行：定义模块名，唯一的。
第四行：定义需要编译的源文件，用相对路径指定
第五行：定义包含的头文件，用绝对路径指定。
第八行：声明该模块编译为可执行程序

